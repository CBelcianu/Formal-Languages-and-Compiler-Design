class Lr0Parser:

    def __init__(self, grammar):
        self.grammar = grammar
        self.working_stack = []
        self.input_stack = []
        self.output = []

    def closure(self, dotted_productions):
        """
        :param dotted_productions: a list of tuples of the form (the symbol before the arrow, the list of symbols after
                                the arrow and the dot)
        :return: a list of tuples similar with the one from the input parameters but with the productions of the
                terminals that had a dot in front of them in the input list
        """

        resulting_productions = dotted_productions
        finished = False

        while not finished:
            finished = True
            for dotted_production in resulting_productions:
                dot_index = dotted_production[1].index('.') #get the position of the dot in the list
                after_dot = dotted_production[1][dot_index + 1:] #get the res of the elements positioned after the dot in the list
                if len(after_dot) != 0:
                    symbol = after_dot[0] #get the first symbol after the dot
                    if self.grammar.is_non_terminal(symbol): #if it is a non_terminal we have to add its productions
                        for production in self.grammar.get_productions_for(symbol):
                            dotted_production = (production[0], ['.'] + production[1]) #add a dot in after the arrow
                            if dotted_production not in resulting_productions: #in this case we have to keep going
                                resulting_productions += [dotted_production]
                                finished = False

        return resulting_productions

    def go_to(self, current_state, current_symbol):
        """
        :param current_state: a list of tuples of the form (the symbol before the arrow, the list of symbols after
                            the arrow and the dot)
        :param current_symbol: the current symbol in the input stack
        :return: a list of tuples similar with the one from the input parameters but with the productions of the
                terminals that had a dot in front of them in the input list
        """
        resulting_productions = []

        for dotted_production in current_state:
            dot_index = dotted_production[1].index('.')
            before_dot = dotted_production[1][:dot_index]
            after_dot = dotted_production[1][dot_index + 1:]

            if len(after_dot) != 0:
                first_symbol, rest_of_symbols = after_dot[0], after_dot[1:] #first symbol after dot and the rest
                if first_symbol == current_symbol:
                    resulting_production = (dotted_production[0], before_dot + [first_symbol] + ['.'] + rest_of_symbols)
                    resulting_productions = resulting_productions + [resulting_production]

        return self.closure(resulting_productions)

    def get_canonical_collection(self):
        """
        :return: the list of all states generated by the grammar.
                list of tuples of the form (the symbol before the arrow, the list of symbols after
                            the arrow and the dot)
        """
        resulting_states = [self.closure([('S1', ['.', self.grammar.starting_symbol])])] #imbogatim gramatica
        finished = False
        while not finished:
            finished = True
            for state in resulting_states:
                list_of_symbols = []
                for production in state:
                    dot_index = production[1].index('.')
                    if dot_index + 1 < len(production[1]):
                        list_of_symbols.append(production[1][dot_index+1])
                for symbol in list_of_symbols:
                    next_state = self.go_to(state, symbol)
                    if next_state and next_state not in resulting_states:
                        resulting_states = resulting_states + [next_state]
                        finished = False

        return resulting_states

    def get_table(self):
        """
        :return: a list of dictionaries, one per state. Each dictionary has as first entry the key 'action' and the value
                the name of the action, and the rest of the entries have as the key the symbol and the value the number
                of the resulting state after applying go_to with the current state and the respective symbol
        """
        states = self.get_canonical_collection()
        table = [{} for state_number in range(len(states))] #make one line for each state

        for state_number, state in enumerate(states): #transfrom the list of states into a list of tuples of the form (state_number, state)
            nr_productions_resulting_in_shift = 0
            nr_productions_resulting_in_reduce = 0
            nr_productions_resulting_in_acc = 0
            production_index = None

            for production in state:
                dotIndex = production[1].index('.')
                before_dot = production[1][:dotIndex]
                after_dot = production[1][dotIndex + 1:]
                if len(after_dot) != 0:
                    nr_productions_resulting_in_shift += 1
                else:
                    if production[0] != 'S1':
                        nr_productions_resulting_in_reduce += 1
                        production_index = self.grammar.production_rules.index((production[0], before_dot))
                    elif before_dot == [self.grammar.starting_symbol]:
                        nr_productions_resulting_in_acc += 1

            if nr_productions_resulting_in_shift == len(state):
                table[state_number]['action'] = 'shift'
            elif nr_productions_resulting_in_reduce == len(state):
                table[state_number]['action'] = 'reduce ' + str(production_index)
            elif nr_productions_resulting_in_acc == len(state):
                table[state_number]['action'] = 'acc'
            else:
                raise (Exception('No action detected for state ' + str(state_number) + ' ' + str(state)))

            list_of_symbols = []
            for production in state:
                dot_index = production[1].index('.')
                if dot_index + 1 < len(production[1]):
                    list_of_symbols.append(production[1][dot_index + 1])
            for symbol in list_of_symbols:
                next_state = self.go_to(state, symbol)
                if next_state in states:
                    table[state_number][symbol] = states.index(next_state)

        return table

    def parse(self, input_sequence):
        """
        :param input_sequence: a list containing symbols
        :return: the list of productions used to generate the sequence
        """
        table = self.get_table()

        self.working_stack = ['0']
        self.input_stack = [symbol for symbol in input_sequence]
        self.output = []

        position = 0
        while len(self.working_stack) != 0:
            symbol = None
            state = int(self.working_stack[-1])
            if len(self.input_stack) > 0:
                symbol = self.input_stack.pop(0)

            if table[state]['action'] == 'shift':
                if symbol not in table[state]:
                    print('state', state)
                    print('symbol', symbol)
                    raise (Exception('Cannot parse shift: ' + str(position)))

                self.working_stack.append(symbol)
                self.working_stack.append(table[state][symbol])
            elif table[state]['action'] == 'acc':
                if len(self.input_stack) != 0:
                    raise (Exception('Cannot Parse acc: ' + str(position)))

                self.working_stack.clear()
            else:
                production_number = int(table[state]['action'].split(' ')[1])
                production_used_to_reduce = self.grammar.production_rules[production_number]
                symbols_to_be_reduced = [symbol for symbol in production_used_to_reduce[1]] # all the symbols that apper after the arrow

                while len(symbols_to_be_reduced) > 0 and len(self.working_stack) > 0:
                    if self.working_stack[-1] == symbols_to_be_reduced[-1]:
                        symbols_to_be_reduced.pop()
                    self.working_stack.pop()

                if len(symbols_to_be_reduced) != 0:
                    raise (Exception('Cannot Parse reduce: ' + str(position)))

                self.input_stack.insert(0, production_used_to_reduce[0])
                self.output.insert(0, str(production_number))
            position += 1

        return self.output
